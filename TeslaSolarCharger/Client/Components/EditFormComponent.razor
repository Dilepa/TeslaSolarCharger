@using Blazored.FluentValidation
@using Microsoft.AspNetCore.Http
@using TeslaSolarCharger.Client.Helper.Contracts
@using TeslaSolarCharger.Client.Wrapper

@inject IHttpClientHelper HttpClientHelper

@typeparam T

<EditForm EditContext="@WrappedElement.EditContext" OnValidSubmit="@(_ => HandleValidSubmit(WrappedElement.Item))">
    <FluentValidationValidator />
    @ChildContent
    <ValidationSummary/>
    @if (!HideSubmitButton)
    {
        <MudPaper Class="d-flex justify-end flex-grow-1 gap-4 pr-2 mb-2" Elevation="0">
            <MudButton Variant="Variant.Filled" Color="Color.Primary" ButtonType="ButtonType.Submit" StartIcon="@Icons.Material.Filled.Save">Save</MudButton>
        </MudPaper>
    }
</EditForm>


@code {

    [Parameter]
    public EditableItem<T> WrappedElement { get; set; }
    [Parameter]
    public RenderFragment ChildContent { get; set; }
    [Parameter]
    public bool HideSubmitButton { get; set; }
    [Parameter]
    public string? SubmitUrl { get; set; }

    [Parameter]
    public EventCallback<T> OnValidSubmit { get; set; }

    public bool IsDirty => WrappedElement.EditContext.IsModified();



    private async Task HandleValidSubmit(T wrappedItem)
    {
        if (SubmitUrl == default)
        {
            _ = OnValidSubmit.InvokeAsync(wrappedItem);
            return;
        }
        var result = await HttpClientHelper.SendPostRequestAsync<object>(SubmitUrl, wrappedItem);
        if (!result.HasError || (result.ProblemDetails?.Status != StatusCodes.Status422UnprocessableEntity))
        {
            return;
        }

        if (result.ProblemDetails?.Extensions.TryGetValue("validationErrors", out var validationErrors) == true)
        {
            // Cast the value to the expected type
            if (validationErrors is IDictionary<string, string[]> errorsDictionary)
            {
                MapErrorsToEditContext(errorsDictionary);
            }
            else
            {
                Console.WriteLine("The validationErrors are not in the expected format.");
            }
        }
        else
        {
            Console.WriteLine("No validationErrors found in ProblemDetails.Extensions.");
        }
        _ = OnValidSubmit.InvokeAsync(wrappedItem);
    }

    private void MapErrorsToEditContext(IDictionary<string, string[]> errors)
    {
        // Clear old messages
        WrappedElement.MessageStore.Clear();

        // Add new messages
        foreach (var fieldWithErrors in errors)
        {
            var fieldIdentifier = new FieldIdentifier(WrappedElement.Item, fieldWithErrors.Key);
            foreach (var errorMessage in fieldWithErrors.Value)
            {
                WrappedElement.MessageStore.Add(fieldIdentifier, errorMessage);
            }
        }

        // Force Blazor to re-render messages
        WrappedElement.EditContext.NotifyValidationStateChanged();
    }


}
